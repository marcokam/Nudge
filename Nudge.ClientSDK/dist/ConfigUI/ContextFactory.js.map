{"version":3,"file":"ContextFactory.js","sourceRoot":"","sources":["../../ConfigUI/ContextFactory.ts"],"names":[],"mappings":"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","sourcesContent":["import { ParameterPersistence } from \"./ParameterPersistence\";\r\nimport { \r\n    ContextSettings,\r\n    Context,\r\n    ParameterMappings,\r\n    FlexibleParameterMappings,\r\n    Params,\r\n    ControlConfiguration,\r\n    ControlInstance,\r\n    emptyContextSettings,\r\n    emptyControlConfiguration\r\n} from \"./ConfigUIInterfaces\";\r\nimport Subscribable from \"./Subscribable\";\r\nimport registry from \"~/Util/registry\";\r\nimport * as StringUtils from \"~/Util/StringUtils\";\r\nimport * as AreEquals from \"~/Comparison/AreEquals\";\r\nimport SdkLogCategories from \"~/Logging/Category/SdkLogCategories\";\r\n\r\nconst logger = registry.categoryLoggers.create(SdkLogCategories.ConfigUI);\r\n\r\nconst findBoundaryContext = (parent: ControlInstance): Context => {\r\n    if (!parent || !parent.context || parent.context.isBoundary || !parent.parent) {\r\n        return parent.context;\r\n    }\r\n    return findBoundaryContext(parent.parent)\r\n}\r\n\r\nexport const convertParameterMappings = (mappings?: FlexibleParameterMappings): ParameterMappings => {\r\n\r\n    const invalid = (msg: string) => new Error(\"Invalid mappings: \" + msg);\r\n    if (!mappings) {\r\n        return {};\r\n    }\r\n    if (Array.isArray(mappings)) {\r\n        const result: ParameterMappings = { };\r\n        (mappings as any[]).forEach(item => {\r\n            if (typeof item === \"string\") {\r\n                const itemStr = item as string;\r\n                result[itemStr] = itemStr;\r\n            } else {\r\n                throw invalid(\"Array elements are not strings.\");\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n\r\n    if (typeof mappings === \"string\") {\r\n        const itemStr = mappings as string;\r\n        return { [itemStr]: itemStr };\r\n    }\r\n\r\n    if (typeof mappings === \"object\") {\r\n        const result: ParameterMappings = { };\r\n        (Object.keys(mappings)).forEach((key: string) => {\r\n            const value: any = mappings[key];\r\n            if (typeof value === \"string\") {\r\n                result[key] = value as string;\r\n            } else {\r\n                throw invalid(\"Object value not a string.\");\r\n            }\r\n        })\r\n        return result;\r\n    }\r\n\r\n    throw invalid(`Invalid type (${typeof mappings}).`);\r\n};\r\n\r\nconst invertParameterMappings = (mappings: ParameterMappings): ParameterMappings => {\r\n    const result: ParameterMappings = {};\r\n    Object.keys(mappings).forEach(key => result[mappings[key]] = key);\r\n    return result;\r\n};\r\n\r\nconst mapParams = (params: Params, mapping: ParameterMappings): Params => {\r\n    \r\n    // mapping = { \"collinsListId\": \"listId\" }\r\n    const toMapKeys = Object.keys(mapping).filter(key => params[key]);\r\n\r\n    // If there's nothing to map, just return an empty object\r\n    if (toMapKeys.length < 1) {\r\n        return {};\r\n    }\r\n\r\n    const result: Params = {};\r\n    toMapKeys.forEach(key => {\r\n        const targetKey = mapping[key];\r\n        result[targetKey] = params[key]\r\n    })\r\n    return result;\r\n};\r\n\r\n// Merges parameters from 2 objects.  The second object wins conflicts.\r\nconst mergeParams = (first: Params, second: Params): Params => Object.assign({}, first, second);\r\n\r\nexport default class ContextFactory {\r\n\r\n    private readonly parameterPersistence: ParameterPersistence;\r\n\r\n    constructor(parameterPersistence: ParameterPersistence) {\r\n        this.parameterPersistence = parameterPersistence;\r\n    }\r\n\r\n    createBoundaryContext = (contextSettings: Partial<ContextSettings>, inputParameters: Params): Promise<Context> => {\r\n\r\n        const fullContextSettings: ContextSettings = Object.assign({}, emptyContextSettings, contextSettings);\r\n        const persisting = fullContextSettings.persistParameters && fullContextSettings.persistenceKey;\r\n        const inputParamMappings = convertParameterMappings(fullContextSettings.inputParameters);\r\n        const mappedInputParams = mapParams(inputParameters, inputParamMappings);\r\n        const fixedAndInputParams = mergeParams(fullContextSettings.fixedParameters, mappedInputParams);\r\n\r\n        const saveParamMapping = convertParameterMappings(fullContextSettings.persistParameters);\r\n        const persistedParameterMappings = invertParameterMappings(saveParamMapping);\r\n\r\n        const templatedPersistenceKey = StringUtils.fromTemplate(fullContextSettings.persistenceKey, fixedAndInputParams);\r\n\r\n        //TODO: Allow nesting contexts?  Push params up to parent / Pull params down from parent.\r\n        const persistedParamsPromise = persisting\r\n            ? this.parameterPersistence.getPersistedParams(templatedPersistenceKey)\r\n            : Promise.resolve({});\r\n        return persistedParamsPromise\r\n            .then(persistedParams => {\r\n                const persitedMapped = mapParams(persistedParams || {}, persistedParameterMappings);\r\n                const mergedStartingParams = mergeParams(persitedMapped, fixedAndInputParams);\r\n                const subscribableParams = new Subscribable<Params>(mergedStartingParams);\r\n\r\n                let lastPersistedParams = persistedParams;\r\n\r\n                const that = this;\r\n                function setParameters(newParams: Params, save: boolean): void {            \r\n                    const oldParams = subscribableParams.getValue();\r\n                    const result = { \r\n                        ...oldParams,\r\n                        ...newParams\r\n                    };            \r\n                    logger.debug(\"BoundaryContext setParameters called\", { oldParams, newParams, result });\r\n                    if (persisting && save) {\r\n                        \r\n                        const paramsToPersist = mapParams(result, saveParamMapping);\r\n                        if (!AreEquals.shallowEquals(lastPersistedParams, paramsToPersist)) {\r\n                            that.parameterPersistence.savePersistedParams(templatedPersistenceKey, paramsToPersist);\r\n                        }\r\n                        lastPersistedParams = paramsToPersist;                        \r\n                    }\r\n                    subscribableParams.setValue(result);\r\n                }\r\n                \r\n                return {\r\n                    getParameters: subscribableParams.getValue,\r\n                    setParameters: (newParams: Params) => setParameters(newParams, true),\r\n                    subscribe: subscribableParams.subscribe,\r\n                    isBoundary: true    \r\n                };\r\n            });\r\n\r\n    }\r\n\r\n    createControlContext = (controlConfiguration: Partial<ControlConfiguration>, parent: ControlInstance): Context => {\r\n        \r\n        const fullControlConfiguration: ControlConfiguration = Object.assign({}, emptyControlConfiguration, controlConfiguration);\r\n        // Params on the control configuration itself are immutable.  Get them right away.\r\n        const myParams = fullControlConfiguration.parameters;\r\n\r\n        // Find the boundary context\r\n        const boundaryContext = findBoundaryContext(parent);\r\n\r\n        // Determine if no inputs\r\n        const inputParamMappings = convertParameterMappings(fullControlConfiguration.inputParameters);\r\n        const noInputs = Object.keys(inputParamMappings).length < 1;\r\n\r\n        // Subscribe to changes on our boundary, and cache the results of a merge\r\n        // for use in context.subscribe and context.getParameters\r\n        const mappedBoundaryParams = mapParams(boundaryContext.getParameters(), inputParamMappings);\r\n        const startingValue = mergeParams(myParams, mappedBoundaryParams);\r\n        const subscribable = new Subscribable<Params>(startingValue);\r\n        if (!noInputs) {\r\n            boundaryContext.subscribe(boundaryParams => {\r\n                const mappedBoundaryParams = mapParams(boundaryParams, inputParamMappings);\r\n                return subscribable.setValue(mergeParams(myParams, mappedBoundaryParams));\r\n            });\r\n        }\r\n\r\n        // Setup a setParameters function\r\n        const outputParamMappings = convertParameterMappings(fullControlConfiguration.outputParameters);\r\n        const noOutputs = Object.keys(outputParamMappings).length < 1;\r\n        const setParameters = noOutputs\r\n            ? () => { }\r\n            : (newParams: Params) => {\r\n                const mappedNewParams = mapParams(newParams, outputParamMappings);\r\n                logger.debug(\"ControlContext setParameters called\", { newParams, mappedNewParams, outputParamMappings});\r\n                boundaryContext.setParameters(mappedNewParams);\r\n            };\r\n        return {\r\n            subscribe: subscribable.subscribe,\r\n            getParameters: subscribable.getValue,\r\n            setParameters,\r\n            isBoundary: false\r\n        };\r\n    }\r\n\r\n}\r\n"]}