{"version":3,"file":"PromiseUtils.js","sourceRoot":"","sources":["../../Util/PromiseUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import { map } from \"./IterableUtils\";\r\nimport AggregateError from \"./AggregateError\";\r\n\r\n// This wraps any function as a promise.\r\n// Any exceptions in that function result in a rejected promise\r\n// regardless of whether that exception happened synchronously or\r\n// asynchronously.\r\n// See:\r\n//  * https://github.com/tc39/proposal-promise-try\r\n//  * http://bluebirdjs.com/docs/api/promise.try.html\r\nexport function promiseTry<T>(fn: () => Promise<T>) {\r\n    return Promise.resolve().then(() => {\r\n        return fn();\r\n    });\r\n}\r\n\r\n// Similar to the concept of a singleton promise, \r\n// except that once the promise completes the next call\r\n// will create a new execution.\r\n// Useful if you only want concurrent executions to join\r\n// but do not save a permanent value.\r\n// See these for examples of singleton promises that are not reusable:\r\n//   * https://www.npmjs.com/package/async-singleton\r\n//   * https://gist.github.com/thomasmichaelwallace/cd77294cac8b6b4ecf054bf2a42fe7fc\r\nexport function reusableSingleton<T>(fn: () => Promise<T>): () => Promise<T> {\r\n    let inflight: Promise<T> | null = null;\r\n    return () => {\r\n        if (inflight === null) {\r\n            inflight = promiseTry(fn);\r\n            // Save it before we clear it\r\n            const thisInflight = inflight;\r\n            inflight.finally(() => inflight = null);\r\n            return thisInflight;\r\n        }\r\n        return inflight;\r\n    };\r\n}\r\n\r\n// Creates a promise that will resolve after a number of milliseconds specified by \"timeoutMs\".\r\n// It will resolve to \"resolveObject\" if specified.\r\nexport function TimeoutPromise<T>(timeoutMs: number, resolveObject: T): Promise<T> {\r\n    return new Promise(resolve => setTimeout(resolve, timeoutMs, resolveObject));\r\n}\r\n\r\nexport const emptyPromise: Promise<null> = Promise.resolve(null);\r\nexport const voidPromise: Promise<void> = Promise.resolve();\r\n\r\n//TODO: Can we do this with AbortController?? This is nuts.\r\ninterface TimeoutObject { \"@@Timeout\": boolean };\r\nconst timeoutObject: TimeoutObject = { \"@@Timeout\": true };\r\nexport function RaceTimeout<T>(promise: Promise<T>, timeoutMs: number): Promise<T | null> {    \r\n    const timeoutPromise: Promise<TimeoutObject> = new Promise(resolve => setTimeout(resolve, timeoutMs, timeoutObject));\r\n    const racing: Promise<T | TimeoutObject> = Promise.race([promise, timeoutPromise]);\r\n    return racing\r\n        .then(result => {\r\n            const maybeTimeout = (result as TimeoutObject)[\"@@Timeout\"];\r\n            if (maybeTimeout) {\r\n                return emptyPromise;\r\n            }\r\n            return Promise.resolve(result as T);\r\n        });\r\n}\r\n\r\nexport const createTimeoutAbortSignal = (timeoutMs: number): AbortSignal => {    \r\n    const controller = new AbortController();\r\n    setTimeout(controller.abort.bind(controller), timeoutMs);\r\n    return controller.signal;\r\n}\r\n\r\nexport const onSignalAbort = (signal: AbortSignal, fn: () => void) => {\r\n    signal.addEventListener(\"abort\", fn);\r\n};\r\n\r\nexport const joinAbortSignals = (...args: AbortSignal[]) => {\r\n    const controller = new AbortController();\r\n    if (args) {\r\n        args.forEach(signal => {\r\n            if (signal) {\r\n                onSignalAbort(signal, controller.abort.bind(controller));\r\n            }\r\n        });\r\n    }\r\n    return controller.signal;\r\n};\r\n\r\n// Causes errors in multiple map functions to be joined into a single error.\r\n// Simply using Promise.all would reject as soon as the first promise rejects\r\n// and other rejections would result in \"unhandledrejection\" events.\r\n//\r\n// Additionally this operates on both synchronous and asynchronous errors.\r\nexport const mapAndJoinErrors = <T, U>(input: Iterable<T>, mapFn: (item: T) => Promise<U>): Promise<U[]> => {\r\n    \r\n    // When there is an error this value will never actually be used\r\n    // but we add it anyways just to make the types line up.\r\n    const valueOnError = Promise.resolve(null as any as U);\r\n\r\n    // Track errors\r\n    const errors: any[] = [];\r\n\r\n    // Save both sync and async errors\r\n    const promises = map(input, item => {\r\n        try {\r\n            return mapFn(item)\r\n                .catch(reason => { errors.push(reason); })\r\n                .then(() => valueOnError);\r\n        } catch (err) {\r\n            errors.push(err);\r\n            return valueOnError;\r\n        }\r\n    });\r\n\r\n    // Wait for all promises to resolve, and throw any errors.\r\n    return Promise.all(promises).then((results: U[]): U[] => {\r\n        if (errors.length === 0) {\r\n            return results;\r\n        } else if (errors.length === 1) {\r\n            throw errors[0];\r\n        } else {\r\n            throw new AggregateError(errors);\r\n        }\r\n    });\r\n}"]}