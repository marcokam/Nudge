{"version":3,"file":"Producer.js","sourceRoot":"","sources":["../../../../Util/fp/Instances/Producer.ts"],"names":[],"mappings":"AAAA,OAAO,EAAU,IAAI,EAAE,MAAM,QAAQ,CAAC;AACtC,OAAO,EAAE,UAAU,EAAE,MAAM,cAAc,CAAC;AAE1C,OAAO,SAAS,MAAM,kBAAkB,CAAC;AAWzC,IAAM,eAAe,GAAG,UAAI,CAAc,IAA4B,OAAA,UAAU,CAAC,CAAC,CAAC,EAAb,CAAa,CAAC;AACpF,MAAM,CAAC,IAAM,cAAc,GAAG,UAAI,CAAW,IAAK,OAAA,CAAC,YAAY,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,YAAY,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,EAArF,CAAqF,CAAC;AAExI,oDAAoD;AACpD,IAAM,SAAS,GAAG,UAAI,CAAc;IAChC,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,EAAE;QACrB,OAAO,cAAc,CAAC,CAAC,CAAC,CAAC;KAC5B;IAED,OAAO,cAAc,CAAC,CAAC,EAAE,CAAC,CAAC;AAC/B,CAAC,CAAA;AAED,+IAA+I;AAC/I,gEAAgE;AAChE,MAAM,CAAC,IAAM,aAAa,GAAG,UAAI,CAAc,IAAuB,OAAA,IAAI,SAAS,CAAC,cAAM,OAAA,SAAS,CAAC,CAAC,CAAC,EAAZ,CAAY,CAAC,CAAC,QAAQ,EAA1C,CAA0C,CAAC;AAEjH,mJAAmJ;AACnJ,4DAA4D;AAC5D,MAAM,CAAC,IAAM,QAAQ,GAAG,UAAI,CAAc,IAAgB,OAAA,IAAI,IAAI,CAAW,cAAM,OAAA,SAAS,CAAC,CAAC,CAAC,EAAZ,CAAY,CAAC,EAAtC,CAAsC,CAAC;AAEjG,yIAAyI;AACzI,4DAA4D;AAC5D,MAAM,CAAC,IAAM,cAAc,GAAG,UAAI,CAAc,IAAgB,OAAA,IAAI,IAAI,CAAW,aAAa,CAAI,CAAC,CAAC,CAAC,EAAvC,CAAuC,CAAC","sourcesContent":["import { Result, Task } from \"./Task\";\r\nimport { isFunction } from \"~/Util/utils\";\r\nimport { Lazy } from \"../function\";\r\nimport LazyValue from \"~/Util/LazyValue\";\r\n\r\ntype SyncProducer<A> = Lazy<A>;\r\ntype AsyncProducer<A> = Lazy<Promise<A>>;\r\ntype ResultProducer<A> = Lazy<Result<A>>;\r\ntype ValueProducer<A> = SyncProducer<A> | AsyncProducer<A> | ResultProducer<A>;\r\n\r\ntype Value<A> = A | Result<A> | Promise<A>;\r\n\r\ntype Producer<A> = Value<A> | ValueProducer<A>;\r\n\r\nconst isValueProducer = <A>(p: Producer<A>): p is ValueProducer<A> => isFunction(p);\r\nexport const valueToPromise = <A>(v: Value<A>) => v instanceof Promise ? v : v instanceof Task ? Task.toPromise(v) : Promise.resolve(v);\r\n\r\n// Execution is not deferred.  Do NOT export this.  \r\nconst toPromise = <A>(p: Producer<A>): Promise<A> => {\r\n    if (!isValueProducer(p)) {\r\n        return valueToPromise(p);\r\n    }\r\n\r\n    return valueToPromise(p());\r\n}\r\n\r\n// Flatten a Producer to a lazy Promise.  The result of invoking Producer is cached, therefore the provided Producer will only be invoked once.\r\n// Execution is deferred until the resulting function is called.\r\nexport const toLazyPromise = <A>(p: Producer<A>): Lazy<Promise<A>> => new LazyValue(() => toPromise(p)).getValue;\r\n\r\n// Flatten a Producer to a Result.  The result of invoking Producer is not cached, therefore the provided Producer could be invoked multiple times.\r\n// Execution is deferred until the resulting Task is forked.\r\nexport const toResult = <A>(p: Producer<A>): Result<A> => new Task<Error, A>(() => toPromise(p));\r\n\r\n// Flatten a Producer to a Result.  The result of invoking Producer is cached, therefore the provided Producer will only be invoked once.\r\n// Execution is deferred until the resulting Task is forked.\r\nexport const toCachedResult = <A>(p: Producer<A>): Result<A> => new Task<Error, A>(toLazyPromise<A>(p));\r\n\r\n/* Provides a type that can actually be several different types.  This allows a function to accept a multitude of types and consumers can choose how they wish to specify them.\r\n   Use `toResult` to flatten all of these types down to just a Result<A>.\r\n   Use `toCachedResult` to flatten to Result<A> but underlying Producer is only executed once and result is cached.\r\n   Use `toLazyPromise` to flatten to () => Promise<A>.  Underlying Producer is only executed once and result is cached.\r\n   We could make a `toPromise` function, but that would not allow deferred execution and would kind of defeat the purpose.\r\n   Possible types include:\r\n    * A value\r\n    * A function that produces a value\r\n    * A Result\r\n    * A function that produces a Result\r\n    * A Promise\r\n    * A function that produces a Promise\r\n*/\r\nexport default Producer;"]}