{"version":3,"file":"Task.js","sourceRoot":"","sources":["../../../../Util/fp/Instances/Task.ts"],"names":[],"mappings":"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","sourcesContent":["import { Lazy, id } from \"../function\";\r\nimport { Monad2 }from \"../Algebras/Monad\";\r\nimport { Either, either, left } from \"./Either\";\r\nimport { Option } from \"./Option\";\r\nimport Producer, { toResult, valueToPromise } from \"./Producer\";\r\nimport { throwError } from \"../error\";\r\n\r\nexport const URI = \"Task\";\r\nexport type URI = typeof URI;\r\n\r\ntype Return<A> = A extends (...args: any[]) => infer R ? R : never;\r\n\r\nexport type Result<T> = Task<Error, T>;\r\nexport class Task<E, A> {\r\n    readonly tag: \"Task\" = \"Task\";\r\n    static ofValue = <A>(a: A): Task<never, A> => new Task<never, A>(() => Promise.resolve(a));\r\n    static of = <E, A>(a: A | Promise<A>): Task<E, A> => new Task(() => valueToPromise(a));\r\n    static fromProducer = <A>(p: Producer<A>) => toResult(p);\r\n    static fromEither = <E, A>(either: Either<E, A>) => new Task(() => Promise.resolve(either.getOrElse(id)));\r\n    static fromOption = <E, A>(option: Option<A>, defaultValue: A) => new Task(() => Promise.resolve(option.getOrElse(() => defaultValue)));\r\n    static reject = <E, A>(e: string): Task<E, A> => new Task(() => Promise.reject(new Error(e)));\r\n    static toPromise = <E extends Error, A>(t: Task<E, A>) => t.fork(throwError, id);\r\n    \r\n    readonly run: Lazy<Promise<Either<E, A>>>\r\n\r\n    constructor(run: Lazy<Promise<A>>) {\r\n        this.run = () => run()\r\n            .then(either.of)\r\n            .catch(left) as unknown as Promise<Either<E, A>>;\r\n    }\r\n    \r\n    readonly map = <B>(f: (a: A) => B): Task<E, B> => new Task(() =>\r\n        this.run()\r\n            .then(either.map(f))\r\n            .then(eitherB => eitherB.fold(id, id))\r\n    );\r\n\r\n    readonly ap = <B>(Tb: Task<E, B>): Task<E, Return<A>> => new Task(() =>\r\n        Promise.all([this.run(), Tb.run()])\r\n            .then(([eitherFunc, eitherB]) => eitherFunc.ap(eitherB))\r\n            .then(eitherB => eitherB.fold(id, id))\r\n    );\r\n\r\n    readonly chain = <B>(f: (a: A) => Task<E, B>): Task<E, B> => new Task(() =>\r\n        this.run()\r\n            .then(either.map(f))\r\n            .then(eitherTaskB => eitherTaskB.fold(\r\n                id, taskB => taskB.fork(id, id)\r\n            ))\r\n    )\r\n\r\n    readonly fork = <E2, A2>(onError: (e: E) => E2, onSuccess: (a: A) => A2): Promise<E2 | A2> =>\r\n        this.run()\r\n            .then(eitherA => eitherA.fold(onError, onSuccess))\r\n            .catch(onError);\r\n}\r\n\r\nexport const map = <E, A, B>(f: (a: A) => B) => (taskA: Task<E, A>) => taskA.map(f);\r\nexport const ap = <E, A, B>(taskAtoB: Task<E, (a: A) => B>) => (taskA: Task<E, A>): Task<E, B> => taskAtoB.ap(taskA);\r\nexport const chain = <E, A, B>(f: (a: A) => Task<E, B>) => (taskA: Task<E, A>) => taskA.chain(f);\r\nexport const of = <E, A>(a: A | Promise<A>) => Task.of<E, A>(a);\r\nexport const task: Monad2<URI> = {\r\n    map,\r\n    ap,\r\n    chain,\r\n    of,\r\n};\r\n"]}