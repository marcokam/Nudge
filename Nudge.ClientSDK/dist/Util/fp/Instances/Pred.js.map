{"version":3,"file":"Pred.js","sourceRoot":"","sources":["../../../../Util/fp/Instances/Pred.ts"],"names":[],"mappings":"AAIA,MAAM,CAAC,IAAM,GAAG,GAAG,MAAM,CAAC;AAG1B;IAOI,cAAY,CAAe;QAA3B,iBAEC;QARQ,QAAG,GAAW,MAAM,CAAC;QAUrB,QAAG,GAAG,UAAC,CAAI,IAAK,OAAA,KAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAb,CAAa,CAAC;QAC9B,cAAS,GAAG,UAAI,CAAc,IAAc,OAAA,IAAI,IAAI,CAAC,UAAC,CAAI,IAAM,OAAA,KAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAd,CAAc,CAAC,EAAnC,CAAmC,CAAC;QAChF,WAAM,GAAG,UAAC,KAAc,IAAc,OAAA,IAAI,IAAI,CAAC,UAAC,CAAI,IAAK,OAAA,KAAI,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,EAA3B,CAA2B,CAAC,EAA/C,CAA+C,CAAC;QACtF,aAAQ,GAAG,UAAC,KAAc,IAAc,OAAA,IAAI,IAAI,CAAC,UAAC,CAAI,IAAK,OAAA,KAAI,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,EAA3B,CAA2B,CAAC,EAA/C,CAA+C,CAAC;QAN7F,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC;IACnB,CAAC;IANM,OAAE,GAAG,UAAI,CAAe,IAAc,OAAA,IAAI,IAAI,CAAC,CAAC,CAAC,EAAX,CAAW,CAAC;IAClD,UAAK,GAAG,cAAS,OAAA,IAAI,IAAI,CAAC,cAAM,OAAA,IAAI,EAAJ,CAAI,CAAuB,EAA1C,CAA0C,CAAC;IAC5D,QAAG,GAAG,UAAI,CAAU,IAAK,OAAA,IAAI,IAAI,CAAC,UAAC,CAAI,IAAK,OAAA,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAT,CAAS,CAAC,EAA7B,CAA6B,CAAC;IAUlE,WAAC;CAAA,AAfD,IAeC;SAfY,IAAI;AAiBjB,MAAM,CAAC,IAAM,SAAS,GAAG,UAAO,CAAc,IAAK,OAAA,UAAC,KAAc,IAAK,OAAA,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,EAAlB,CAAkB,EAAtC,CAAsC,CAAC;AAC1F,MAAM,CAAC,IAAM,MAAM,GAAG,UAAI,MAAe,IAAK,OAAA,UAAC,MAAe,IAAK,OAAA,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,EAArB,CAAqB,EAA1C,CAA0C,CAAC;AACzF,MAAM,CAAC,IAAM,KAAK,GAAG,cAAS,OAAA,IAAI,CAAC,KAAK,EAAK,EAAf,CAAe,CAAC;AAC9C,MAAM,CAAC,IAAM,IAAI,GAAuC;IACpD,SAAS,WAAA;IACT,KAAK,OAAA;IACL,MAAM,QAAA;CACT,CAAC","sourcesContent":["import { Monoid1 } from \"../Algebras/Monoid\";\r\nimport { Contravariant1 } from \"../Algebras/Contravariant\";\r\nimport { Predicate } from \"../function\";\r\n\r\nexport const URI = \"Pred\";\r\nexport type URI = typeof URI;\r\n \r\nexport class Pred<A> {\r\n    readonly tag: \"Pred\" = \"Pred\";\r\n    private readonly value: Predicate<A>;\r\n    static of = <A>(a: Predicate<A>): Pred<A> => new Pred(a);\r\n    static empty = <A>() => new Pred(() => true) as unknown as Pred<A>;\r\n    static not = <A>(p: Pred<A>) => new Pred((a: A) => !p.run(a));\r\n\r\n    constructor(a: Predicate<A>) {\r\n        this.value = a;\r\n    }\r\n    \r\n    readonly run = (a: A) => this.value(a);\r\n    readonly contramap = <B>(f: (b: B) => A): Pred<B> => new Pred((b: B ) => this.run(f(b)));\r\n    readonly concat = (predA: Pred<A>): Pred<A> => new Pred((a: A) => this.run(a) && predA.run(a));\r\n    readonly concatOr = (predA: Pred<A>): Pred<A> => new Pred((a: A) => this.run(a) || predA.run(a));\r\n}\r\n\r\nexport const contramap = <A, B>(f: (b: B) => A) => (predA: Pred<A>) => predA.contramap(f);\r\nexport const concat = <A>(predA1: Pred<A>) => (predA2: Pred<A>) => predA1.concat(predA2);\r\nexport const empty = <A>() => Pred.empty<A>();\r\nexport const pred: Contravariant1<URI> & Monoid1<URI> = {\r\n    contramap,\r\n    empty,\r\n    concat,\r\n};\r\n"]}