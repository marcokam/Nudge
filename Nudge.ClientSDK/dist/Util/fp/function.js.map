{"version":3,"file":"function.js","sourceRoot":"","sources":["../../../Util/fp/function.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAUA;;GAEG;AACH,MAAM,CAAC,IAAM,IAAI,GAAG,cAAO,CAAC,CAAC;AAC7B,MAAM,CAAC,IAAM,EAAE,GAAG,UAAI,CAAI,IAAQ,OAAA,CAAC,EAAD,CAAC,CAAC;AACpC,MAAM,CAAC,IAAM,QAAQ,GAAG,UAAI,CAAI,IAAK,OAAA,cAAM,OAAA,CAAC,EAAD,CAAC,EAAP,CAAO,CAAC;AAE7C,MAAM,CAAC,IAAM,SAAS,GAAG,UAAI,CAAI,IAA0B,OAAA,CAAC,CAAC,IAAI,IAAI,CAAC,EAAX,CAAW,CAAC;AACvE,MAAM,CAAC,IAAM,IAAI,GAAG,UAAC,CAA0B;IAC3C,IAAI,MAAM,GAAG,KAAK,CAAC;IACnB,OAAO;QAAC,cAAc;aAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;YAAd,yBAAc;;QAClB,IAAI,MAAM;YAAE,OAAO;QACnB,CAAC,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QACpB,MAAM,GAAG,IAAI,CAAC;IAClB,CAAC,CAAC;AACN,CAAC,CAAA;AACD,MAAM,CAAC,IAAM,GAAG,GAAG,UAAI,CAAoB,IAAK,OAAA,UAAC,CAAI,IAAK,OAAA,CAAC,CAAC,CAAC,CAAC,CAAC,EAAL,CAAK,EAAf,CAAe,CAAC;AAEhE,MAAM,CAAC,IAAM,OAAO,GAAG,UAAI,EAAyB;IAAzB,mBAAA,EAAA,OAAyB;IAAK,OAAA,UAAC,CAAI,IAAK,OAAA,EAAE,CAAC,MAAM,GAAG,CAAC,IAAI,EAAE,CAAC,KAAK,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,CAAC,CAAC,EAAJ,CAAI,CAAC,EAApC,CAAoC;AAA9C,CAA8C,CAAC;AACxG,MAAM,CAAC,IAAM,OAAO,GAAG,UAAI,EAAyB;IAAzB,mBAAA,EAAA,OAAyB;IAAK,OAAA,UAAC,CAAI,IAAK,OAAA,EAAE,CAAC,IAAI,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,CAAC,CAAC,EAAJ,CAAI,CAAC,EAAlB,CAAkB;AAA5B,CAA4B,CAAC;AAwEtF,MAAM,UAAU,OAAO;IAAsB,aAAkB;SAAlB,UAAkB,EAAlB,qBAAkB,EAAlB,IAAkB;QAAlB,wBAAkB;;IAC3D,OAAO,GAAG,CAAC,MAAM,CAAC,UAAC,CAAC,EAAE,CAAC,IAAK,OAAA;QAAC,cAAU;aAAV,UAAU,EAAV,qBAAU,EAAV,IAAU;YAAV,yBAAU;;QAAK,OAAA,CAAC,CAAC,CAAC,wBAAI,IAAI,GAAE;IAAb,CAAa,EAA7B,CAA6B,CAAC,CAAC;AAC/D,CAAC;AAwED,MAAM,UAAU,IAAI,CAAyB,EAAkB;IAAE,aAAkB;SAAlB,UAAkB,EAAlB,qBAAkB,EAAlB,IAAkB;QAAlB,4BAAkB;;IAC/E,OAAO;QAAC,cAAU;aAAV,UAAU,EAAV,qBAAU,EAAV,IAAU;YAAV,yBAAU;;QAAK,OAAA,GAAG,CAAC,MAAM,CAAC,UAAC,CAAC,EAAE,CAAC,IAAK,OAAA,CAAC,CAAC,CAAC,CAAC,EAAJ,CAAI,EAAE,EAAE,wBAAI,IAAI,GAAE;IAAvC,CAAuC,CAAC;AACnE,CAAC","sourcesContent":["import { CompareResult } from \"~/Util/sortUtils\";\r\n\r\n/**\r\n * Types and Type Aliases\r\n */\r\nexport type Predicate<A> = (a: A) => boolean\r\nexport type Lazy<A> = () => A;\r\nexport type Comparator<A> = (a: A, b: A) => CompareResult;\r\n\r\n\r\n/**\r\n * Functions\r\n */\r\nexport const noop = () => {};\r\nexport const id = <A>(a: A): A => a;\r\nexport const constant = <A>(a: A) => () => a;\r\n\r\nexport const isNotNull = <A>(a: A): a is NonNullable<A> => (a != null);\r\nexport const once = (f: (...args: any[]) => any) => {\r\n    let called = false;\r\n    return (...args: any[]) => {\r\n        if (called) return;\r\n        f.apply(null, args);\r\n        called = true;\r\n    };\r\n}\r\nexport const not = <A>(f: (a: A) => boolean) => (a: A) => !f(a);\r\n\r\nexport const allPass = <A>(fs: (Predicate<A>)[] = []) => (a: A) => fs.length > 0 && fs.every(f => f(a));\r\nexport const anyPass = <A>(fs: (Predicate<A>)[] = []) => (a: A) => fs.some(f => f(a));\r\n\r\nexport function compose<A extends unknown[], B>(ab: (...a: A) => B): (...a: A) => B;\r\nexport function compose<A extends unknown[], B, C>(bc: (b: B) => C, ab: (...a: A) => B): (...a: A) => C;\r\nexport function compose<A extends unknown[], B, C, D>(\r\n    cd: (c: C) => D,\r\n    bc: (b: B) => C,\r\n    ab: (...a: A) => B\r\n): (...a: A) => D;\r\nexport function compose<A extends unknown[], B, C, D, E>(\r\n    de: (d: D) => E,\r\n    cd: (c: C) => D,\r\n    bc: (b: B) => C,\r\n    ab: (...a: A) => B\r\n): (...a: A) => E;\r\nexport function compose<A extends unknown[], B, C, D, E, F>(\r\n    ef: (e: E) => F,\r\n    de: (d: D) => E,\r\n    cd: (c: C) => D,\r\n    bc: (b: B) => C,\r\n    ab: (...a: A) => B\r\n): (...a: A) => F;\r\nexport function compose<A extends unknown[], B, C, D, E, F, G>(\r\n    fg: (f: F) => G,\r\n    ef: (e: E) => F,\r\n    de: (d: D) => E,\r\n    cd: (c: C) => D,\r\n    bc: (b: B) => C,\r\n    ab: (...a: A) => B\r\n): (...a: A) => G;\r\nexport function compose<A extends unknown[], B, C, D, E, F, G, H>(\r\n    gh: (g: G) => H,\r\n    fg: (f: F) => G,\r\n    ef: (e: E) => F,\r\n    de: (d: D) => E,\r\n    cd: (c: C) => D,\r\n    bc: (b: B) => C,\r\n    ab: (...a: A) => B\r\n): (...a: A) => H;\r\nexport function compose<A extends unknown[], B, C, D, E, F, G, H, I>(\r\n    hi: (h: H) => I,\r\n    gh: (g: G) => H,\r\n    fg: (f: F) => G,\r\n    ef: (e: E) => F,\r\n    de: (d: D) => E,\r\n    cd: (c: C) => D,\r\n    bc: (b: B) => C,\r\n    ab: (...a: A) => B\r\n): (...a: A) => I;\r\nexport function compose<A extends unknown[], B, C, D, E, F, G, H, I, J>(\r\n    ij: (i: I) => J,\r\n    hi: (h: H) => I,\r\n    gh: (g: G) => H,\r\n    fg: (f: F) => G,\r\n    ef: (e: E) => F,\r\n    de: (d: D) => E,\r\n    cd: (c: C) => D,\r\n    bc: (b: B) => C,\r\n    ab: (...a: A) => B\r\n): (...a: A) => J;\r\nexport function compose<A extends unknown[], B, C, D, E, F, G, H, I, J, K>(\r\n    jk: (j: J) => K,\r\n    ij: (i: I) => J,\r\n    hi: (h: H) => I,\r\n    gh: (g: G) => H,\r\n    fg: (f: F) => G,\r\n    ef: (e: E) => F,\r\n    de: (d: D) => E,\r\n    cd: (c: C) => D,\r\n    bc: (b: B) => C,\r\n    ab: (...a: A) => B\r\n): (...a: A) => K;\r\nexport function compose<A extends unknown[]>(...fns: Function[]) {\r\n    return fns.reduce((f, g) => (...args: A) => f(g(...args)));\r\n}\r\n\r\nexport function pipe<A extends unknown[], B>(ab: (...a: A) => B): (...a: A) => B\r\nexport function pipe<A extends unknown[], B, C>(ab: (...a: A) => B, bc: (b: B) => C): (...a: A) => C\r\nexport function pipe<A extends unknown[], B, C, D>(\r\n    ab: (...a: A) => B,\r\n    bc: (b: B) => C,\r\n    cd: (c: C) => D,\r\n): (...a: A) => D\r\nexport function pipe<A extends unknown[], B, C, D, E>(\r\n    ab: (...a: A) => B,\r\n    bc: (b: B) => C,\r\n    cd: (c: C) => D,\r\n    de: (d: D) => E,\r\n): (...a: A) => E\r\nexport function pipe<A extends unknown[], B, C, D, E, F>(\r\n    ab: (...a: A) => B,\r\n    bc: (b: B) => C,\r\n    cd: (c: C) => D,\r\n    de: (d: D) => E,\r\n    ef: (e: E) => F,\r\n): (...a: A) => F\r\nexport function pipe<A extends unknown[], B, C, D, E, F, G>(\r\n    ab: (...a: A) => B,\r\n    bc: (b: B) => C,\r\n    cd: (c: C) => D,\r\n    de: (d: D) => E,\r\n    ef: (e: E) => F,\r\n    fg: (f: F) => G,\r\n): (...a: A) => G\r\nexport function pipe<A extends unknown[], B, C, D, E, F, G, H>(\r\n    ab: (...a: A) => B,\r\n    bc: (b: B) => C,\r\n    cd: (c: C) => D,\r\n    de: (d: D) => E,\r\n    ef: (e: E) => F,\r\n    fg: (f: F) => G,\r\n    gh: (g: G) => H,\r\n): (...a: A) => H\r\nexport function pipe<A extends unknown[], B, C, D, E, F, G, H, I>(\r\n    ab: (...a: A) => B,\r\n    bc: (b: B) => C,\r\n    cd: (c: C) => D,\r\n    de: (d: D) => E,\r\n    ef: (e: E) => F,\r\n    fg: (f: F) => G,\r\n    gh: (g: G) => H,\r\n    hi: (h: H) => I,\r\n): (...a: A) => I\r\nexport function pipe<A extends unknown[], B, C, D, E, F, G, H, I, J>(\r\n    ab: (...a: A) => B,\r\n    bc: (b: B) => C,\r\n    cd: (c: C) => D,\r\n    de: (d: D) => E,\r\n    ef: (e: E) => F,\r\n    fg: (f: F) => G,\r\n    gh: (g: G) => H,\r\n    hi: (h: H) => I,\r\n    ij: (i: I) => J,\r\n): (...a: A) => J\r\nexport function pipe<A extends unknown[], B, C, D, E, F, G, H, I, J, K>(\r\n    ab: (...a: A) => B,\r\n    bc: (b: B) => C,\r\n    cd: (c: C) => D,\r\n    de: (d: D) => E,\r\n    ef: (e: E) => F,\r\n    fg: (f: F) => G,\r\n    gh: (g: G) => H,\r\n    hi: (h: H) => I,\r\n    ij: (i: I) => J,\r\n    jk: (j: J) => K,\r\n): (...a: A) => K\r\nexport function pipe<A extends unknown[], B>(f1: (...a: A) => B, ...fns: Function[]) {\r\n    return (...args: A) => fns.reduce((v, f) => f(v), f1(...args));\r\n}\r\n"]}