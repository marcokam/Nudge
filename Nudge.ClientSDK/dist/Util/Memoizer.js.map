{"version":3,"file":"Memoizer.js","sourceRoot":"","sources":["../../Util/Memoizer.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,SAAS,MAAM,wBAAwB,CAAC;AAOpD,wCAAwC;AACxC,4CAA4C;AAC5C;IAOI,6BAAY,QAAgC,EAAE,cAA4B;QAA1E,iBAGC;QAED,iBAAY,GAAG,UAAC,KAAS;YACrB,IAAI,KAAI,CAAC,MAAM,KAAK,SAAS,IAAI,KAAI,CAAC,KAAK,KAAK,SAAS,IAAI,CAAC,KAAI,CAAC,cAAc,CAAC,KAAK,EAAE,KAAI,CAAC,KAAK,CAAC,EAAE;gBAClG,IAAM,MAAM,GAAG,KAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;gBACpC,KAAI,CAAC,KAAK,GAAG,KAAK,CAAC;gBACnB,KAAI,CAAC,MAAM,GAAG,MAAM,CAAC;gBACrB,OAAO,MAAM,CAAC;aACjB;YACD,OAAO,KAAI,CAAC,MAAM,CAAC;QACvB,CAAC,CAAA;QAZG,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,cAAc,GAAG,cAAc,IAAI,SAAS,CAAC,YAAY,CAAC;IACnE,CAAC;IAWL,0BAAC;AAAD,CAAC,AArBD,IAqBC","sourcesContent":["import { AreEqual } from \"~/Comparison/ComparisonInterfaces\";\r\nimport * as AreEquals from \"~/Comparison/AreEquals\";\r\n\r\nexport type ValueProducer<In, Out> = (input: In) => Out;\r\nexport interface Memoizer<In, Out> {\r\n    computeValue: ValueProducer<In, Out>;\r\n}\r\n\r\n// Memoizes only a single value at once.\r\n// If input changes, old value is discarded.\r\nexport class SingleValueMemoizer<In, Out> implements Memoizer<In, Out> {\r\n    \r\n    private readonly producer: ValueProducer<In, Out>;\r\n    private readonly inputsAreEqual: AreEqual<In>;\r\n    private input: In | undefined;\r\n    private output: Out | undefined;\r\n\r\n    constructor(producer: ValueProducer<In, Out>, inputsAreEqual: AreEqual<In>) {\r\n        this.producer = producer;\r\n        this.inputsAreEqual = inputsAreEqual || AreEquals.strictEquals;\r\n    }\r\n\r\n    computeValue = (input: In): Out => {\r\n        if (this.output === undefined || this.input === undefined || !this.inputsAreEqual(input, this.input)) {\r\n            const result = this.producer(input);\r\n            this.input = input;\r\n            this.output = result;\r\n            return result;\r\n        }\r\n        return this.output;\r\n    }\r\n}"]}