{"version":3,"file":"WebAppTokenManager.js","sourceRoot":"","sources":["../../Authentication/WebAppTokenManager.ts"],"names":[],"mappings":"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","sourcesContent":["import TokenManager, { TokenRefreshResponse } from \"./TokenManager\";\r\nimport {  invariantTruthy } from \"~/Util/utils\";\r\nimport { reusableSingleton, promiseTry, createTimeoutAbortSignal } from \"~/Util/PromiseUtils\";\r\nimport HttpError from \"~/Api/Errors/HttpError\";\r\nimport registry from \"~/Util/registry\";\r\n\r\nexport interface WebAppTokenManagerSettings {\r\n    readonly startingAccessToken: string;\r\n    readonly refreshUrl: string;\r\n    readonly initialExpirySeconds?: number;\r\n    readonly isImpersonating: boolean;\r\n    readonly userName: string;\r\n    readonly expirationThresholdSeconds: number;\r\n    readonly onAccessTokenChange: (newAccessToken: string | null) => void;\r\n    readonly onRefreshFail: () => void;\r\n    readonly additionalHeaders: any;\r\n}\r\nconst defaultSettings = {\r\n    startingAccessToken: null,\r\n    isImpersonating: false,\r\n    expirationThresholdSeconds: 280,\r\n    userName: \"\",    \r\n    onAccessTokenChange: () => {},\r\n    onRefreshFail: () => {}\r\n}\r\nexport default class WebAppTokenManager implements TokenManager {\r\n    \r\n    private readonly settings: WebAppTokenManagerSettings;\r\n    private refreshTimeoutFunc?: NodeJS.Timeout;\r\n    private currentAccessToken: string | null;\r\n\r\n    constructor(settings: Partial<WebAppTokenManagerSettings>) {\r\n        const finalSettings = Object.assign({}, defaultSettings, settings);\r\n        invariantTruthy(finalSettings.refreshUrl, \"missing refreshUrl\");\r\n\r\n        this.settings = finalSettings as WebAppTokenManagerSettings;\r\n        if (this.settings.initialExpirySeconds) {\r\n            this.refreshTimeoutFunc = this.createRefreshTimeout(this.settings.initialExpirySeconds);\r\n        }\r\n        this.currentAccessToken = this.settings.startingAccessToken;\r\n    }\r\n\r\n    supportsRefresh = true;\r\n\r\n    getAccessToken = () => this.currentAccessToken;\r\n\r\n    refreshAccessToken = (): Promise<TokenRefreshResponse> => {\r\n        return this.performRefresh();\r\n    }\r\n\r\n    private createRefreshTimeout = (accessTokenExpiresInSeconds: number): NodeJS.Timeout => {\r\n        // Refresh the access token when it is close to expiring\r\n        var intervalSeconds = Math.max(accessTokenExpiresInSeconds - this.settings.expirationThresholdSeconds, 0);        \r\n        return setTimeout(this.performRefreshAndCatch, intervalSeconds * 1000);\r\n    }\r\n\r\n    private performRefreshAndCatch = () => this.performRefresh().catch(() => {});\r\n    private performRefresh = reusableSingleton(() => promiseTry(() => { \r\n    \r\n        registry.logger.info(\"Refreshing tokens.\");\r\n        const body = this.settings.isImpersonating ? { \"impersonateUser\" : this.settings.userName } : { };\r\n        const signal = createTimeoutAbortSignal(10000); // 10 seconds\r\n        const options: RequestInit = {\r\n            method: \"POST\",\r\n            body: JSON.stringify(body),\r\n            headers: {\r\n                \"Accept\": \"application/json\",\r\n                \"Pragma\": \"no-cache\",\r\n                \"Cache-Control\": \"no-cache\",\r\n                \"Expires\": \"0\",\r\n                ...this.settings.additionalHeaders\r\n            },\r\n            credentials: \"same-origin\",\r\n            signal\r\n        };\r\n        return fetch(this.settings.refreshUrl, options);\r\n    })\r\n        .then(response => {\r\n            if (response.ok) {\r\n                return response;        \r\n            }\r\n            \r\n            // Refresh token is invalid.  Log the user out.\r\n            //TODO: Consider waiting until the last minute - when the access token is invalid AND refresh fails.\r\n            if (response.status === 403) {\r\n                this.settings.onRefreshFail();\r\n            }\r\n            \r\n            throw new HttpError(response);\r\n        })\r\n        .then(response => response.json())\r\n        .then(responseObj => {\r\n            const accessToken = responseObj.accessToken;\r\n            const accessTokenExpiresInSeconds = responseObj.accessTokenExpiresInSeconds;\r\n            if (!accessToken) {\r\n                throw Error(\"Missing access token from refresh API response.\");\r\n            }\r\n            if (!accessTokenExpiresInSeconds) {\r\n                throw Error(\"Missing accessTokenExpiresInSeconds from refresh API response.\");\r\n            }\r\n    \r\n            this.currentAccessToken = accessToken;\r\n            this.settings.onAccessTokenChange(accessToken);\r\n            if (this.refreshTimeoutFunc) clearTimeout(this.refreshTimeoutFunc);\r\n            this.refreshTimeoutFunc = this.createRefreshTimeout(accessTokenExpiresInSeconds);\r\n            const response: TokenRefreshResponse = {\r\n                success: true,\r\n                accessToken: accessToken\r\n            };\r\n            return response;\r\n        })\r\n        .catch(err => {\r\n            registry.logger.error(\"Error refreshing tokens.\", err);\r\n            if (this.refreshTimeoutFunc) clearTimeout(this.refreshTimeoutFunc);\r\n            const response: TokenRefreshResponse = {\r\n                success: false,\r\n                accessToken: null\r\n            };\r\n            return response;\r\n        }));    \r\n\r\n}\r\n"]}